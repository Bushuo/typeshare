use std::{collections::HashMap, io::Write};

use crate::{
    parser::ParsedData,
    rust_types::{
        RustEnum,
        RustEnumVariant::{self},
        RustField, RustStruct, RustType, RustTypeFormatError, SpecialRustType,
    },
    RenameExt,
};

use super::{Language, SupportedLanguage};

#[derive(Default)]
/// All information needed to generate Rescript type-code
pub struct ReScript {
    /// Mappings from Rust type names to Rescript type names
    pub type_mappings: HashMap<String, String>,
    /// Whether or not to exclude the version header that normally appears at the top of generated code.
    /// If you aren't generating a snapshot test, this setting can just be left as a default (false)
    pub no_version_header: bool,
}

impl Language for ReScript {
    fn type_map(&mut self) -> &HashMap<String, String> {
        &self.type_mappings
    }

    fn format_type(
        &mut self,
        ty: &RustType,
        generic_types: &[String],
    ) -> Result<String, RustTypeFormatError> {
        match ty {
            RustType::Simple { id } => self.format_simple_type(id, generic_types),
            RustType::Generic { id, parameters } => {
                self.format_generic_type(id, parameters.as_slice(), generic_types)
            }
            RustType::Special(special) => self.format_special_type(special, generic_types),
        }
        .map(|ty| ty.to_camel_case())
    }

    fn format_special_type(
        &mut self,
        special_ty: &SpecialRustType,
        generic_types: &[String],
    ) -> Result<String, RustTypeFormatError> {
        match special_ty {
            SpecialRustType::Vec(rtype) => Ok(format!(
                "array<{}>",
                self.format_type(rtype, generic_types)?
            )),
            SpecialRustType::Array(rtype, _) => Ok(format!(
                "array<{}>",
                self.format_type(rtype, generic_types)?
            )),
            SpecialRustType::Slice(rtype) => Ok(format!(
                "array<{}>",
                self.format_type(rtype, generic_types)?
            )),
            // We add optionality above the type formatting level
            SpecialRustType::Option(rtype) => self.format_type(rtype, generic_types),
            SpecialRustType::HashMap(rtype1, rtype2) => Ok(format!(
                "Map.t<{}, {}>",
                match rtype1.as_ref() {
                    RustType::Simple { id } if generic_types.contains(id) => {
                        return Err(RustTypeFormatError::GenericKeyForbiddenInRescript(
                            id.clone(),
                        ));
                    }
                    _ => self.format_type(rtype1, generic_types)?,
                },
                self.format_type(rtype2, generic_types)?
            )),
            SpecialRustType::Unit => Ok("unit".into()),
            SpecialRustType::String => Ok("string".into()),
            SpecialRustType::Char => Ok("string".into()),
            SpecialRustType::I8
            | SpecialRustType::U8
            | SpecialRustType::I16
            | SpecialRustType::U16
            | SpecialRustType::I32
            | SpecialRustType::U32
            | SpecialRustType::I54
            | SpecialRustType::U53 => Ok("int".into()),
            SpecialRustType::F32 | SpecialRustType::F64 => Ok("float".into()),
            SpecialRustType::Bool => Ok("bool".into()),
            SpecialRustType::U64
            | SpecialRustType::I64
            | SpecialRustType::ISize
            | SpecialRustType::USize => {
                panic!("64 bit types not allowed in Typeshare")
            }
        }
    }

    fn write_imports(
        &mut self,
        w: &mut dyn Write,
        _imports: super::ScopedCrateTypes<'_>,
    ) -> std::io::Result<()> {
        // All types are in the same flat namespace in Rescript
        writeln!(w)
    }

    fn begin_file(&mut self, w: &mut dyn Write, _parsed_data: &ParsedData) -> std::io::Result<()> {
        if !self.no_version_header {
            writeln!(w, "/*")?;
            writeln!(w, " Generated by typeshare {}", env!("CARGO_PKG_VERSION"))?;
            writeln!(w, "*/")?;
            writeln!(w)?;
        }
        Ok(())
    }

    fn write_struct(&mut self, w: &mut dyn Write, rs: &RustStruct) -> std::io::Result<()> {
        self.write_comments(w, 0, &rs.comments)?;
        writeln!(
            w,
            "type {}{} = {{",
            rs.id.renamed.to_camel_case(),
            (!rs.generic_types.is_empty())
                .then(|| format!("<{}>", rs.generic_types.join(", ")))
                .unwrap_or_default()
        )?;

        rs.fields
            .iter()
            .try_for_each(|f| self.write_field(w, f, rs.generic_types.as_slice()))?;

        writeln!(w, "}}\n")
    }

    fn write_enum(&mut self, w: &mut dyn Write, e: &RustEnum) -> std::io::Result<()> {
        self.write_comments(w, 0, &e.shared().comments)?;

        let generic_parameters = (!e.shared().generic_types.is_empty())
            .then(|| format!("<{}>", e.shared().generic_types.join(", ")))
            .unwrap_or_default();

        match e {
            RustEnum::Unit(shared) => {
                write!(
                    w,
                    "type {}{} =",
                    shared.id.renamed.to_camel_case(),
                    generic_parameters
                )?;

                self.write_enum_variants(w, e)?;

                writeln!(w, "\n")
            }
            RustEnum::Algebraic {
                shared, tag_key, ..
            } => {
                // in Rescript we need to write out the inner types of the struct variants
                // because anonymous record types are not allowed in the position of the content key
                let tuple_struct_variants = shared
                    .variants
                    .iter()
                    .filter(|v| matches!(v, RustEnumVariant::AnonymousStruct { .. }))
                    .cloned()
                    .collect::<Vec<_>>();

                if !tuple_struct_variants.is_empty() {
                    tuple_struct_variants.iter().try_for_each(|v| match v {
                        RustEnumVariant::AnonymousStruct {
                            fields,
                            shared: variant_shared,
                        } => {
                            writeln!(
                                w,
                                "type {}_{} = {{",
                                shared.id.renamed.to_camel_case(),
                                variant_shared.id.renamed
                            )?;
                            fields.iter().try_for_each(|f| {
                                self.write_field(w, f, e.shared().generic_types.as_slice())
                            })?;
                            writeln!(w, "}}")
                        }

                        RustEnumVariant::Tuple { .. } => unreachable!(),
                        RustEnumVariant::Unit(_) => unreachable!(),
                    })?;
                }

                writeln!(w, "@tag(\"{}\")", tag_key)?;
                write!(
                    w,
                    "type {}{} =",
                    shared.id.renamed.to_camel_case(),
                    generic_parameters
                )?;

                self.write_enum_variants(w, e)?;

                writeln!(w, "\n")
            }
        }
    }
}

impl ReScript {
    fn write_comments(
        &mut self,
        w: &mut dyn Write,
        indent: usize,
        comments: &[String],
    ) -> std::io::Result<()> {
        // Only attempt to write a comment if there are some, otherwise we're Ok()
        if comments.is_empty() {
            return Ok(());
        }

        let comment: String = {
            let tab_indent = "\t".repeat(indent);
            // If there's only one comment then keep it on the same line, otherwise we'll make a nice multi-line comment
            if comments.len() == 1 {
                format!("{}/** {} */", tab_indent, comments.first().unwrap())
            } else {
                let joined_comments = comments.join(&format!("\n{} * ", tab_indent));
                format!(
                    "{tab}/**
{tab} * {comment}
{tab} */",
                    tab = tab_indent,
                    comment = joined_comments
                )
            }
        };
        writeln!(w, "{}", comment)
    }

    fn write_field(
        &mut self,
        w: &mut dyn Write,
        field: &RustField,
        generic_types: &[String],
    ) -> std::io::Result<()> {
        self.write_comments(w, 1, &field.comments)?;
        let rs_ty: String = match field.type_override(SupportedLanguage::ReScript) {
            Some(type_override) => type_override.to_owned(),
            None => self
                .format_type(&field.ty, generic_types)
                .map_err(|e| std::io::Error::new(std::io::ErrorKind::Other, e))?,
        };

        let optional = field.ty.is_optional() || field.has_default;
        writeln!(
            w,
            "\t{}: {},",
            &field.id.renamed,
            optional
                .then(|| format!("option<{}>", rs_ty))
                .unwrap_or(rs_ty),
        )?;

        Ok(())
    }

    fn write_enum_variants(&mut self, w: &mut dyn Write, e: &RustEnum) -> std::io::Result<()> {
        match e {
            // Write all the unit variants out (there can only be unit variants in this case)
            // @as("variant_name") is a Rescript feature that allows us to customize how the variant is represented
            // at runtime. In case of unit variants, we use the variant name as the runtime representation
            RustEnum::Unit(shared) => shared.variants.iter().try_for_each(|v| match v {
                RustEnumVariant::Unit(shared) => {
                    write!(
                        w,
                        "\t | @as(\"{}\") {}",
                        shared.id.renamed, shared.id.renamed
                    )
                }
                _ => unreachable!(),
            }),

            // Write all the algebraic variants out (all three variant types are possible here)
            RustEnum::Algebraic {
                shared,
                content_key,
                ..
            } => shared.variants.iter().try_for_each(|v| {
                writeln!(w)?;
                self.write_comments(w, 1, &v.shared().comments)?;
                match v {
                    RustEnumVariant::Unit(shared) => {
                        // We add (unit) here to achieve the same representation as serde_json
                        write!(
                            w,
                            "\t | @as(\"{}\") {}(unit)",
                            shared.id.renamed, shared.id.renamed
                        )
                    }
                    RustEnumVariant::Tuple {
                        ty,
                        shared: variant_shared,
                    } => {
                        let ty = self
                            .format_type(ty, e.shared().generic_types.as_slice())
                            .map_err(|e| std::io::Error::new(std::io::ErrorKind::Other, e))?;
                        write!(
                            w,
                            "\t | @as(\"{}\") {}({{{}: {}}})",
                            variant_shared.id.renamed, variant_shared.id.renamed, content_key, ty
                        )
                    }
                    RustEnumVariant::AnonymousStruct {
                        shared: variant_shared,
                        ..
                    } => {
                        write!(
                            w,
                            "\t | @as(\"{}\") {}({{{}: {}_{}}})",
                            variant_shared.id.renamed,
                            variant_shared.id.renamed,
                            content_key,
                            shared.id.renamed.to_camel_case(),
                            variant_shared.id.renamed
                        )
                    }
                }
            }),
        }
    }
}
